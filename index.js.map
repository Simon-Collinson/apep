{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n    APEN\n    \n    Dada engine inspired library.\n*/\nrequire(\"babel-polyfill\");\nconst walker = require('walker-sample');\n\nconst randomInt = (min, max, r) =>\n    Math.floor(r() * (max - min)) + min;\n\n/**\n    Pac\n*/\nconst Pair = (x, s) => ({\n    'x': x,\n    's': s\n});\n\n/**\n*/\nconst Generador = function(run) {\n    this.run = run;\n};\n\n/**\n    Internal state object.\n*/\nconst State = (vars, ud) => ({\n    'vars': vars,\n    'ud': ud\n});\n\nState.empty = State({}, null);\n\nState.setUd = (s, ud) =>\n    State(s.vars, ud);\n\nState.setVars = (s, vars) =>\n    State(vars, s.ud);\n\nState.getVar = (s, name, def) =>\n    s.vars.hasOwnProperty(name)\n        ? s.vars[name]\n        : def;\n\nState.setVar = (s, name, value) => {\n    const newVars = Object.create(s.vars);\n    newVars[name] = value;\n    return State.setVars(s, newVars);\n};\n\n/**\n    Run a given generator.\n*/\nexport const execute = function*(p, s, r) {\n    return yield* p.run()(s, r);\n};\n\n/**\n    Declare a generator for self reference or late bindings.\n        \n    @param def Function that takes a reference to generator being defined and\n        returns the generator's definition.\n        \n    Anonymous self reference:\n    \n        gen.declare((self) =>\n            gen.seq(m, self));\n            \n    Use of forward declarations:\n    \n        // Use `m` before it is declared or defined.\n        const ms = gen.declare(() =>\n            gen.seq(m, self));\n            \n        const m = gen.lit('n');\n    \n    Later declaration: \n    \n        // Declare that the some generator `ms` will exist.\n        let ms = gen.declare(() => ms);\n        \n        // Use `ms` in any expression.\n        const p = gen.seq('a', ms);\n        \n        ...\n        \n        // Actually define `ms` sometime later.\n        ms = gen.str('abc');\n\n    Also can be used to introduce simple, scoped state:\n        \n        const counter = gen.declare(() => {\n            // declare some variables local to this block.\n            let sum = 0;\n\n            return gen.seq(\n                gen.seq(gen.str(1), gen.str(2), gen.str(3))\n                    .map(x => {\n                        // Update the state in an expression.\n                        sum += i;\n                        return x;\n                    }),\n                // and use the state sometime later.\n                // Declare is used to make sure the current value of `i` is\n                // always returned.\n                gen.declare(() => gen.lit(i)));\n        });\n            \n    For performance reasons, use declare around the smallest possible generator\n    since declare evaluates it's body every time the generator is invoked. \n*/\nexport const declare = (def) => {\n    let self;\n    return self = new Generador(() =>\n        function*(s, r) {\n            yield* execute(def(self), s, r);\n        });\n};\n\n/**\n    Generate a literal value without any transformations applied.\n*/\nexport const lit = (x) =>\n    new Generador(() =>\n        function*(s, _) {\n            const v = Pair(x, s);\n            yield v;\n            return v;\n        });\n\n/**\n    Generate an empty value.\n*/\nexport const empty = lit('');\n\n/**\n    Generate a literal string value.\n    \n    Attempts to convert the input value to a string.\n*/\nexport const str = function(x) {\n    return arguments.length === 0 ? empty : lit('' +  x);\n};\n\n/**\n    Ensure value is inside a generator.\n    \n    Convert any literals into string literals.\n*/\nexport const wrap = (x) =>\n    x instanceof Generador ? x : str(x);\n\n/**\n    Run `a` and then `run b`.\n*/\nexport const next = (a, b) => {\n    a = wrap(a);\n    b = wrap(b);\n    return new Generador(() =>\n        function*(s1, r) {\n            const {s} = yield* execute(a, s1, r);\n            return yield* execute(b, s, r);\n        });\n};\n\n/**\n    Run a sequence of generators left to right.\n    \n    Literal values are wrapped and converted to strings:\n    \n        gen.seq('a', g1, 3) === gen.seq(gen.str('a'), g1, gen.str(3))\n*/\nexport const seq = (...elements) =>\n    elements.reduceRight((p, c) => next(c, p));\n\n/**\n    Map function `f` over each element produced by `p`.\n*/\nexport const map = (p, f) =>\n    new Generador(() =>\n        function*(s1, r) {\n            let s = s1;\n            for (let v of execute(p, s, r)) {\n                s = v.s\n                yield Pair(f(v.x), s);\n            }\n        });\n\n/**\n    Choose from along one or more generators, each with its own custom weight.\n*/\nexport const weightedChoice = (weightMap) => {\n    const table = walker(weightMap.map(x => [x[0], wrap(x[1])]));\n    return new Generador(() =>\n        function*(s, r) {\n            const selected = table(r);\n            return yield* execute(selected, s, r);\n        });\n};\n\n/**\n     Choose from along one or more generators, each with the same weight.\n     \n     @param elements Array of elements\n*/\nexport const choicea = (elements) =>\n    weightedChoice(elements.map(x => [1, x]));\n\n/**\n     Choose from along one or more generators taken as arguments.\n*/\nexport const choice = (...elements) =>\n    choicea(elements);\n\n/**\n    Begin the execution of a generator.\n    \n    @param g Generator.\n    @param ud Optional user data threaded through the generator's states.\n    @param r Random number generator.\n*/\nexport const exec = function*(g, ud, r = Math.random) {\n    for (let x of execute(g, State.setUd(State.empty, ud), r))\n        yield x.x;\n};\n\n/**\n    Left fold over a generator.\n    \n    @param f Function taking accumulated value and current value.\n    @param z Initial value.\n    @param g Generator.\n    @param ud Optional user data threaded through the generator's states.\n    @param r Random number generator.\n*/\nexport const fold = (f, z, g, ud, r = Math.random) => {\n    for (const x of exec(g, ud, r))\n        z = f(z, x);\n    return z;\n};\n\n/**\n    Run a generator to completion, combining results into a string.\n    \n    @see exec\n*/\nexport const run = fold.bind(null, (p, c) => p + c, '');"],"sourceRoot":"/source/"}